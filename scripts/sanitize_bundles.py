#!/usr/bin/env python3
"""Sanitize canonical bundle files by removing conversational transcript markers
and redacting local paths / emails. Makes backups before modifying files.

Usage: run inside WSL repository root or from anywhere with repo path.
"""
import re
from datetime import datetime
from pathlib import Path

ROOT = Path(__file__).resolve().parents[1]
CANONICAL = ROOT / "docs" / "canonical"
BACKUP_SUFFIX = datetime.utcnow().strftime("bak.%Y%m%dT%H%M%SZ")

MARKERS = [
    r"You said:",
    r"Monday said:",
    r"Uploaded image",
    r"_Generated by Copilot",
    r"Generated by Copilot Autopilot",
    r"Uploaded file",
]

PATH_RE = re.compile(r"\\\\wsl\.localhost\\[^\s]+", re.IGNORECASE)
EMAIL_RE = re.compile(r"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}")
MARKER_RE = re.compile("|".join(re.escape(m) for m in MARKERS), re.IGNORECASE)


def sanitize_text(text: str) -> str:
    out_lines = []
    skip_mode = False
    for line in text.splitlines():
        # if a marker appears anywhere in the line, truncate the line at the marker
        m = MARKER_RE.search(line)
        if m:
            # keep any preceding content before the marker (if any), otherwise drop the line
            prefix = line[: m.start()].rstrip()
            if prefix:
                # redact paths and emails in the kept prefix
                prefix = PATH_RE.sub("[REDACTED_PATH]", prefix)
                prefix = EMAIL_RE.sub("[REDACTED_EMAIL]", prefix)
                out_lines.append(prefix)
            # start skipping the following conversational block lines
            skip_mode = True
            continue
        if skip_mode:
            # stop skipping if we hit an empty line or a markdown header or separator
            if (
                line.strip() == ""
                or line.strip().startswith("#")
                or line.strip().startswith("---")
            ):
                skip_mode = False
            else:
                # continue skipping conversational block
                continue
        # redact paths and emails inline
        line = PATH_RE.sub("[REDACTED_PATH]", line)
        line = EMAIL_RE.sub("[REDACTED_EMAIL]", line)
        out_lines.append(line)

    # collapse excessive blank lines (max 2)
    cleaned = []
    blank_count = 0
    for line in out_lines:
        if line.strip() == "":
            blank_count += 1
            if blank_count <= 2:
                cleaned.append(line)
        else:
            blank_count = 0
            cleaned.append(line)
    return "\n".join(cleaned) + "\n"


def backup(p: Path):
    dst = p.with_name(p.name + "." + BACKUP_SUFFIX)
    p.rename(dst)
    return dst


def sanitize_bundle_file(p: Path):
    text = p.read_text(encoding="utf-8")
    sanitized = sanitize_text(text)
    if sanitized == text:
        return False
    # backup original
    bak = backup(p)
    p.write_text(sanitized, encoding="utf-8")
    print(f"Sanitized: {p} (backup: {bak.name})")
    return True


def regenerate_dump(bundles):
    dump_path = CANONICAL / "TEC_CODEX_DUMP.md"
    # backup dump if exists
    if dump_path.exists():
        dump_path.rename(CANONICAL / (dump_path.name + "." + BACKUP_SUFFIX))
    with dump_path.open("w", encoding="utf-8") as out:
        for b in bundles:
            out.write(b.read_text(encoding="utf-8"))
            out.write("\n\n")
    print(f"Regenerated: {dump_path}")
    return dump_path


def main():
    bundles = sorted(CANONICAL.glob("*-bundle.md"))
    print(f"Found {len(bundles)} bundle files in {CANONICAL}")
    changed = 0
    for b in bundles:
        changed += 1 if sanitize_bundle_file(b) else 0

    print(f"Sanitized {changed} files (out of {len(bundles)})")
    regenerate_dump(bundles)


if __name__ == "__main__":
    main()
