#!/usr/bin/env python3
"""Sanitize TEC_CODEX_DUMP.md by removing conversational transcripts and PII.

Usage:
  python3 scripts/sanitize_codex_dump.py --in docs/canonical/TEC_CODEX_DUMP.md --out docs/canonical/TEC_CODEX_DUMP.md

This script creates a timestamped backup of the input file before writing the sanitized output.
"""
import argparse
import re
import datetime
from pathlib import Path


MARKERS = [
    "you said:",
    "monday said:",
    "uploaded image",
    "generated by copilot autopilot",
    "_generated by copilot autopilot",
    "you are the engineering steward",
]


def is_marker_line(line: str) -> bool:
    low = line.lower()
    return any(m in low for m in MARKERS)


def redact_pii_line(line: str) -> str:
    # redact emails
    line = re.sub(
        r"\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b", "[REDACTED EMAIL]", line
    )
    # redact UNC/Windows paths and wsl.localhost paths
    line = re.sub(r"\\\\wsl\.localhost\\[^\s`\n]+", "[REDACTED PATH]", line)
    line = re.sub(r"\\\\[^\s`\n]+", "[REDACTED PATH]", line)
    line = re.sub(r"[A-Za-z]:\\[^\s`\n]+", "[REDACTED PATH]", line)
    # redact http(s) URLs with potential credentials (leave normal URLs intact)
    line = re.sub(r"\bhttps?://\S*@\S+\b", "[REDACTED URL]", line)
    return line


def sanitize_text(text: str) -> str:
    out_lines = []
    lines = text.splitlines()
    i = 0
    n = len(lines)
    redacted_blocks = 0
    while i < n:
        line = lines[i]
        if is_marker_line(line):
            # Skip until a blank line or a header/bundle separator is reached
            redacted_blocks += 1
            # consume current line and subsequent non-empty lines until separator
            i += 1
            while i < n:
                nxt = lines[i]
                if nxt.strip() == "":
                    i += 1
                    break
                # if next line looks like a bundle header or markdown section header, stop
                if re.match(r"^---", nxt) or re.match(r"^#", nxt):
                    break
                i += 1
            out_lines.append("[REDACTED CONVERSATION]")
            out_lines.append("")
            continue

        # redact PII inside line
        safe = redact_pii_line(line)
        out_lines.append(safe)
        i += 1

    return "\n".join(out_lines), redacted_blocks


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--in", dest="infile", required=True, help="Input TEC_CODEX_DUMP.md path"
    )
    parser.add_argument(
        "--out",
        dest="outfile",
        required=True,
        help="Output sanitized path (can overwrite)",
    )
    args = parser.parse_args()

    infile = Path(args.infile)
    outfile = Path(args.outfile)

    if not infile.exists():
        print(f"Input file not found: {infile}")
        raise SystemExit(1)

    # backup
    ts = datetime.datetime.utcnow().strftime("%Y%m%dT%H%M%SZ")
    backup = infile.with_suffix(infile.suffix + f".bak.{ts}")
    infile.replace(backup)
    # write sanitized output reading from backup
    text = backup.read_text(encoding="utf-8")
    sanitized, blocks = sanitize_text(text)
    outfile.write_text(sanitized, encoding="utf-8")

    print(f"Sanitized file written to: {outfile}")
    print(f"Backup of original saved as: {backup}")
    print(f"Redacted conversation blocks: {blocks}")


if __name__ == "__main__":
    main()
